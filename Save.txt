#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <queue>
#include <string>
#include <unordered_set>
#include <functional>
#include <algorithm>
using namespace std;

struct State {

    vector<vector<int>> board;  //текущее состояние доски
    int g;  // стоимость от начального состояния
    int h;  // эвристическая оценка до конечного
    int f;  // f = g + h
    string moves;  // последовательность ходов

    
    bool operator>(const State& other) const {
        return f > other.f;
    }
};


string boardToString(const vector<vector<int>>& board);
int manhattanDistance(const State& state, int n);
bool isSolvable(const vector<vector<int>>& board, int n);
string solveAStar(const vector<vector<int>>& start, int n, const vector<vector<int>>& goal);

int main() {
    int k;
    cin >> k;

    // Проверка ограничений
    if (k < 3 || k > 5) {
        cerr << "не соблюдено ограничение размерности!" << endl;
        return 1;
    }

    // Создание и заполнение массива
    vector<int> numbers(k * k);

    // Ввод данных
    for (int i = 0; i < k * k; i++) {
        cin >> numbers[i];
    }

    // Проверка корректности ввода данных
    vector<int> copy = numbers;
    sort(copy.begin(), copy.end());

    for (int i = 1; i < k * k; i++) {
        if (copy[i - 1] == copy[i]) {  
            cerr << "значения повторяются!" << endl;
            return 1;
        }
    }

    // Создание структуры игрового поля
    vector<vector<int>> field(k, vector<int>(k));
    int count = 0;
    for (int x = 0; x < k; x++) {
        for (int y = 0; y < k; y++) {  
            field[x][y] = numbers[count++];
        }
    }

    // Создание целевого состояния
    vector<vector<int>> goal(k, vector<int>(k));
    int num = 1;
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < k; j++) {
            if (i == k - 1 && j == k - 1) {
                goal[i][j] = 0;
            }
            else {
                goal[i][j] = num++;
            }
        }
    }

    // Запуск алгоритма
    string result = solveAStar(field, k, goal);
    cout << result << endl;

    return 0;
}

string boardToString(const vector<vector<int>>& board) {    //функция для представления состояние в строковом формате
    string result;
    for (const auto& row : board) {
        for (int val : row) {
            result += to_string(val) + ",";
        }
    }
    return result;
}

int manhattanDistance(const State& state, int n) {
    int distance = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int value = state.board[i][j];
            if (value != 0) {

                // целевое расположение плитки
                int targetX = (value - 1) / n;
                int targetY = (value - 1) % n;
                distance += abs(i - targetX) + abs(j - targetY);
            }
        }
    }
    return distance;
}

bool isSolvable(const vector<vector<int>>& board, int n) {
    vector<int> linear;
    for (const auto& row : board) {
        for (int val : row) {
            if (val != 0) linear.push_back(val);
        }
    }

    //подсчет инверсий
    int inversions = 0;
    for (int i = 0; i < linear.size(); i++) {
        for (int j = i + 1; j < linear.size(); j++) {
            if (linear[i] > linear[j]) inversions++;
        }
    }

    //номер строки с пустой клеткой
    int emptyRow = -1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 0) {
                emptyRow = n - i;  
                break;
            }
        }
        break;
    }

    return (inversions % 2 == 0) != (emptyRow % 2 == 0);
}

string solveAStar(const vector<vector<int>>& start, int n, const vector<vector<int>>& goal) {
    // оценка решаемости
    if (!isSolvable(start, n)) {
        return "No solution - puzzle is not solvable";
    }
    // Создаём начальное состояние
    State startState;
    startState.board = start;
    startState.g = 0;  // стоимость от начала
    startState.moves = "";
    startState.h = manhattanDistance(startState, n); 
    startState.f = startState.g + startState.h;    // общая оценка

    // Приоритетная очередь для A* 
    priority_queue<State, vector<State>, greater<State>> pq;
    pq.push(startState);

    // Направления движений: вверх, вправо, вниз, влево
    vector<pair<int, int>> directions = {
        {-1, 0},  // вверх
        {0, 1},   // вправо
        {1, 0},   // вниз
        {0, -1}   // влево
    };

    vector<string> dirNames = { "U", "R", "D", "L" };
    unordered_set<string> visited;                      //для фиксации пройденных точек
    while (!pq.empty()) {

        //состояние с наименьшей оценкой f(лучшее)
        State current = pq.top();
        pq.pop();

        // Преобразование в строку
        string stateStr = boardToString(current.board);

        //если равняется предыдущему - пропуск
        if (visited.find(stateStr) != visited.end()) {
            continue;
        }

        // Отметить как посещённое
        visited.insert(stateStr);

        
        if (current.board == goal) {
            return current.moves;  //последовательность ходов
        }

        // поиск пустой клетки
        int zeroX = -1, zeroY = -1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (current.board[i][j] == 0) {
                    zeroX = i;
                    zeroY = j;
                    break;
                }
            }
            if (zeroX != -1) break;
        }

        //генерация возможных ходов
        for (int d = 0; d < 4; d++) {
            int newX = zeroX + directions[d].first;
            int newY = zeroY + directions[d].second;

            // Проверка пределов
            if (newX >= 0 && newX < n && newY >= 0 && newY < n) {
                // Создаём новую доску как копию текущей
                vector<vector<int>> newBoard = current.board;

                // Меняем местами пустую клетку и соседнюю плитку
                swap(newBoard[zeroX][zeroY], newBoard[newX][newY]);

                // Преобразуем новую доску в строку для проверки
                string newStateStr = boardToString(newBoard);

                // Если уже посещали это состояние, пропускаем
                if (visited.find(newStateStr) != visited.end()) {
                    continue;
                }

                // Создаём новое состояние
                State nextState;
                nextState.board = newBoard;
                nextState.g = current.g + 1;  // на 1 ход больше
                nextState.moves = current.moves + dirNames[d];  // + ход
                nextState.h = manhattanDistance(nextState, n);  // эвристика
                nextState.f = nextState.g + nextState.h;     // новая оценка

                //очередь приоритетов
                pq.push(nextState);
            }
        }
    }

    return "No solution found";
}
